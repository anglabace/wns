package leetcode.date_20181107;

/**
 * 
 * 题目描述：有效的数独
 * 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

        数字 1-9 在每一行只能出现一次。
        数字 1-9 在每一列只能出现一次。
        数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
        
        数独部分空格内已填入了数字，空白格用 '.' 表示。
        
        示例 1:
        
        输入:
        [
          ["5","3",".",".","7",".",".",".","."],
          ["6",".",".","1","9","5",".",".","."],
          [".","9","8",".",".",".",".","6","."],
          ["8",".",".",".","6",".",".",".","3"],
          ["4",".",".","8",".","3",".",".","1"],
          ["7",".",".",".","2",".",".",".","6"],
          [".","6",".",".",".",".","2","8","."],
          [".",".",".","4","1","9",".",".","5"],
          [".",".",".",".","8",".",".","7","9"]
        ]
        输出: true
        示例 2:
        
        输入:
        [
          ["8","3",".",".","7",".",".",".","."],
          ["6",".",".","1","9","5",".",".","."],
          [".","9","8",".",".",".",".","6","."],
          ["8",".",".",".","6",".",".",".","3"],
          ["4",".",".","8",".","3",".",".","1"],
          ["7",".",".",".","2",".",".",".","6"],
          [".","6",".",".",".",".","2","8","."],
          [".",".",".","4","1","9",".",".","5"],
          [".",".",".",".","8",".",".","7","9"]
        ]
        输出: false
        解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
             但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
   
    解题思路：在接触到该题，首先想到了通过map的形式来存储每行的结果，这个的问题是一个map只能存储一行或者列，无法形成一个m*n的维度
    之后，在网上看到了通过二维数组的形式存储， 这样就避免了刚才说的问题。
    
    下一个问题就是9方格怎么处理？这个就需要将其划分成不同的9方格，从左到右，从上到下，依次计数，如第一排，1、2、3，第二行为4、5、6 。。。
    
    说明一下二维数组，怎么计数，如rowFlag[3][5]，表示，第3行，5的数字是否存在，true表示存在，false表示不存在。列的方式一致。
    
    9方格的方式cellFlag[3][5]，表示第3个9方格，是否存在5.关于9方格的计算方式3 * (i/3) + j/3，这个公式比较简单，相信将来的自己能想明白。
    
    具体实现，就在下文了。
    
    题目链接：https://leetcode-cn.com/problems/valid-sudoku/
 * @author woniu
 *
 */
public class ValidSudoku
{
    public boolean isValidSudoku(char[][] board) {
        
        return isVaildColumnAndRow(board);
    }
    
    //这里的执行效率为m*n
    public boolean isVaildColumnAndRow(char[][] board) {
        
        int m = board.length;
        int n = board[0].length;
        
        boolean[][] rowFlag = new boolean[m][n];//用于存储行是否出现了该数字
        boolean[][] columnFlag = new boolean[m][n];//用于存储列是否出现该数字
        boolean[][] cellFlag = new boolean[m][n];//用于存储9方格是否出现该数字
        
        
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(board[i][j] >='1' && board[i][j] <='9'){
                    int num = board[i][j] - '1';//求出当前字母代表的数组下标
                    if(rowFlag[i][num] || columnFlag[j][num] || cellFlag[3 * (i/3) + j/3][num] ){//有一个不满足条件，则直接退出
                        return false;
                    }
                    rowFlag[i][num] = true;//更新三个维度的数组
                    columnFlag[j][num] = true;
                    cellFlag[3 * (i/3) + j/3][num] = true;
                }
            }
        }
        return true;
    }
    
}
